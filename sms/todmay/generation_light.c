/*****************************************************************************
* Model: generation_light_biotics.qm
* File:  ./generation_light.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/*${.::generation_light.c} .................................................*/
#include "qpc.h"
#include "generation_light.h"
#include "bsp.h"                   // Change this file for different platforms
//#include "service.h"
#include "biotics.h"


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

//Q_DEFINE_THIS_FILE

/*${SMs::Biotics} ..........................................................*/
typedef struct {
/* protected: */
    QHsm super;

/* private: */
    int8_t Abilities;
    uint16_t Timer;
    uint8_t Color;

/* public: */
    int8_t Signal;
} Biotics;

/* protected: */
static QState Biotics_initial(Biotics * const me, QEvt const * const e);
static QState Biotics_active(Biotics * const me, QEvt const * const e);
static QState Biotics_ready(Biotics * const me, QEvt const * const e);
static QState Biotics_I(Biotics * const me, QEvt const * const e);
static QState Biotics_II(Biotics * const me, QEvt const * const e);
static QState Biotics_III(Biotics * const me, QEvt const * const e);
static QState Biotics_IV(Biotics * const me, QEvt const * const e);
static QState Biotics_IM(Biotics * const me, QEvt const * const e);
static QState Biotics_IIM(Biotics * const me, QEvt const * const e);
static QState Biotics_IIIM(Biotics * const me, QEvt const * const e);

static Biotics biotics; /* the only instance of the Biotics class */


/*${SMs::Hand} .............................................................*/
typedef struct {
/* protected: */
    QHsm super;
} Hand;

/* protected: */
static QState Hand_initial(Hand * const me, QEvt const * const e);
static QState Hand_able(Hand * const me, QEvt const * const e);


static Hand hand; /* the only instance of the Biotics class */

/* global-scope definitions -----------------------------------------*/
QHsm * const the_biotics = (QHsm *)&biotics;       /* the opaque pointer */
QHsm * const the_hand = (QHsm *)&hand;       /* the opaque pointer */

/*${SMs::Biotics_ctor} .....................................................*/
void Biotics_ctor(void) {
    Biotics *me = &biotics;
    QHsm_ctor(&me->super, Q_STATE_CAST(&Biotics_initial));


}
/*${SMs::Biotics} ..........................................................*/
/*${SMs::Biotics::SM} ......................................................*/
static QState Biotics_initial(Biotics * const me, QEvt const * const e) {
    /* ${SMs::Biotics::SM::initial} */
    (void)e; /* avoid compiler warning */
    me->Timer = 0;

    return Q_TRAN(&Biotics_ready);
}
/*${SMs::Biotics::SM::active} ..............................................*/
static QState Biotics_active(Biotics * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${SMs::Biotics::SM::active} */
        case Q_ENTRY_SIG: {

            status_ = Q_HANDLED();
            break;
        }
        /* ${SMs::Biotics::SM::active::TICK_SEC} */
        case TICK_SEC_SIG: {
            if (me->Timer > 0) {
                me->Timer--;
            }
            /* ${SMs::Biotics::SM::active::TICK_SEC::[me->Timer==1]} */
            if (me->Timer == 1) {
                me->Timer = 0;
                status_ = Q_TRAN(&Biotics_ready);
            }
            /* ${SMs::Biotics::SM::active::TICK_SEC::[else]} */
            else {
                status_ = Q_HANDLED();
            }
            break;
        }

        /* ${SMs::Biotics::SM::active::CHARGE} */
        case I_SIG: {
            status_ = Q_TRAN(&Biotics_I);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

static QState Biotics_I(Biotics * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        case Q_ENTRY_SIG: {
            BIO_SET_TO(Long);
            vibro(30);
            RGB_blink_stop();
            status_ = Q_HANDLED();
            break;
        }
        case I_SIG: {
            me->Signal = e->sig;
            status_ = Q_TRAN(&Biotics_IM);
            break;
        }

        case II_SIG: {
            me->Signal = e->sig;
            status_ = Q_TRAN(&Biotics_II);
            break;
        }

        case III_SIG: {
            me->Signal = e->sig;
            status_ = Q_TRAN(&Biotics_III);
            break;
        }

        case IV_SIG: {
            me->Signal = e->sig;
            status_ = Q_TRAN(&Biotics_IV);
            break;
        }

        default: {
            status_ = Q_SUPER(&Biotics_active);
            break;
        }
    }
    return status_;
}

static QState Biotics_IM(Biotics * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${SMs::Biotics::SM::active::song} */
        case Q_ENTRY_SIG: {
            BIO_SET_TO(Short);
            vibro(100);
            RGB_blink_fast(VIOLET);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Biotics_active);
            break;
        }
    }
    return status_;
}

static QState Biotics_II(Biotics * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${SMs::Biotics::SM::active::song} */
        case Q_ENTRY_SIG: {
            BIO_SET_TO(Short);
            vibro(100);
            RGB_blink_fast(BLUE);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Biotics_active);
            break;
        }
    }
    return status_;
}

static QState Biotics_III(Biotics * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${SMs::Biotics::SM::active::song} */
        case Q_ENTRY_SIG: {
            BIO_SET_TO(Short);
            vibro(100);
            RGB_blink_fast(YELLOW);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Biotics_active);
            break;
        }
    }
    return status_;
}

static QState Biotics_IV(Biotics * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        case Q_ENTRY_SIG: {
            BIO_SET_TO(Long);
            vibro(60);
            RGB_blink_stop();
            status_ = Q_HANDLED();
            break;
        }
        case II_SIG: {
            me->Signal = e->sig;
            status_ = Q_TRAN(&Biotics_IIM);
            break;
        }

        case III_SIG: {
            me->Signal = e->sig;
            status_ = Q_TRAN(&Biotics_IIIM);
            break;
        }

        default: {
            status_ = Q_SUPER(&Biotics_active);
            break;
        }
    }
    return status_;
}

static QState Biotics_IIM(Biotics * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${SMs::Biotics::SM::active::song} */
        case Q_ENTRY_SIG: {
            BIO_SET_TO(Short);
            vibro(100);
            RGB_blink_fast(RED);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Biotics_active);
            break;
        }
    }
    return status_;
}

static QState Biotics_IIIM(Biotics * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${SMs::Biotics::SM::active::song} */
        case Q_ENTRY_SIG: {
            BIO_SET_TO(Short);
            vibro(100);
            RGB_blink_fast(GREEN);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Biotics_active);
            break;
        }
    }
    return status_;
}

static QState Biotics_ready(Biotics * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${SMs::Biotics::SM::active::ready} */
        case Q_ENTRY_SIG: {
            vibro(OFF);
            RGB_blink_stop();
            me->Color = BLANK;
            status_ = Q_HANDLED();
            break;
        }
        /* ${SMs::Biotics::SM::active::ready::CHARGE} */
        case I_SIG: {
            status_ = Q_TRAN(&Biotics_I);
            break;
        }
        default: {
            status_ = Q_SUPER(&Biotics_active);
            break;
        }
    }
    return status_;
}


/*${SMs::Hand_ctor} ........................................................*/
void Hand_ctor(void) {
    Hand *me = &hand;
    QHsm_ctor(&me->super, Q_STATE_CAST(&Hand_initial));

}
/*${SMs::Hand} .............................................................*/
/*${SMs::Hand::SM} .........................................................*/
static QState Hand_initial(Hand * const me, QEvt const * const e) {
    /* ${SMs::Hand::SM::initial} */
    (void)e; /* avoid compiler warning */
    BIO_init();
    return Q_TRAN(&Hand_able);
}
/*${SMs::Hand::SM::able} ...................................................*/
static QState Hand_able(Hand * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${SMs::Hand::SM::able} */
        case Q_ENTRY_SIG: {
            #ifdef DEBUG_SM
                printf("Hand able;");
            #endif
            status_ = Q_HANDLED();
            break;
        }
        /* ${SMs::Hand::SM::able::PUNCH_PILL} */
        case PUNCH_PILL_SIG: {
            BIO_ENABLE(PUNCH);
            status_ = Q_HANDLED();
            break;
        }
        /* ${SMs::Hand::SM::able::PUNCH_PWR_PILL} */
        case PUNCH_PWR_PILL_SIG: {
            BIO_PWR_ENABLE(PUNCH);
            status_ = Q_HANDLED();
            break;
        }
        /* ${SMs::Hand::SM::able::LIFT_PILL} */
        case LIFT_PILL_SIG: {
            BIO_ENABLE(LIFT);
            status_ = Q_HANDLED();
            break;
        }
        /* ${SMs::Hand::SM::able::MAX_PILL} */
        case MAX_PILL_SIG: {
            BIO_set_max();
            status_ = Q_HANDLED();
            break;
        }
        /* ${SMs::Hand::SM::able::LIFT_PWR_PILL} */
        case LIFT_PWR_PILL_SIG: {
            BIO_PWR_ENABLE(LIFT);
            status_ = Q_HANDLED();
            break;
        }
        /* ${SMs::Hand::SM::able::WARP_PILL} */
        case WARP_PILL_SIG: {
            BIO_ENABLE(WARP);
            status_ = Q_HANDLED();
            break;
        }
        /* ${SMs::Hand::SM::able::WARP_PWR_PILL} */
        case WARP_PWR_PILL_SIG: {
            BIO_PWR_ENABLE(WARP);
            status_ = Q_HANDLED();
            break;
        }
        /* ${SMs::Hand::SM::able::CLEANSE_PILL} */
        case CLEANSE_PILL_SIG: {
            BIO_PWR_ENABLE(CLEANSE);
            status_ = Q_HANDLED();
            break;
        }
        /* ${SMs::Hand::SM::able::BARRIER_PILL} */
        case BARRIER_PILL_SIG: {
            BIO_ENABLE(BARRIER);
            status_ = Q_HANDLED();
            break;
        }
        /* ${SMs::Hand::SM::able::SINGULARITY_PILL} */
        case SINGULARITY_PILL_SIG: {
            BIO_ENABLE(SINGULAR);
            status_ = Q_HANDLED();
            break;
        }
        /* ${SMs::Hand::SM::able::SONG_PILL} */
        case SONG_PILL_SIG: {
            BIO_ENABLE(SONG);
            status_ = Q_HANDLED();
            break;
        }
        /* ${SMs::Hand::SM::able::DEFAULT_PILL} */
        case DEFAULT_PILL_SIG: {
            BIO_set_default();
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}


