/*****************************************************************************
* Model: generation_light_ownFW.qm
* File:  ./generation_light.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/*${.::generation_light.c} .................................................*/
#include "qpc.h"
#include "generation_light.h"
#include "service.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//Q_DEFINE_THIS_FILE

int DebugSM = 1;


static void blinkFast(Hand * const me, uint8_t color) {
    me->fbBlinkOn = 250;
    me->fbBlinkOff = 250;
    me->fbColor = color;
}

static void blinkSlow(Hand * const me, uint8_t color) {
    me->fbBlinkOn = 500;
    me->fbBlinkOff = 500;
    me->fbColor = color;    
}

static void blinkStop(Hand * const me) {
    me->fbBlinkOn = 0;
    me->fbBlinkOff = 0;
    me->fbColor = BLANK;  
}

static void vibro(Hand * const me, uint8_t vibro) {
    me->fbVibro = vibro;
}

/* protected: */
static QState Hand_initial(Hand * const me, QEvt const * const e);
static QState Hand_active(Hand * const me, QEvt const * const e);
static QState Hand_charged(Hand * const me, QEvt const * const e);
static QState Hand_song(Hand * const me, QEvt const * const e);
static QState Hand_ready(Hand * const me, QEvt const * const e);
static QState Hand_cast_direct(Hand * const me, QEvt const * const e);
static QState Hand_release(Hand * const me, QEvt const * const e);
static QState Hand_singularity(Hand * const me, QEvt const * const e);
static QState Hand_barrier(Hand * const me, QEvt const * const e);
static QState Hand_pwr_release(Hand * const me, QEvt const * const e);
static QState Hand_throw(Hand * const me, QEvt const * const e);
static QState Hand_cleanse(Hand * const me, QEvt const * const e);
static QState Hand_final(Hand * const me, QEvt const * const e);


static Hand hand; /* the only instance of the Hand class */

/* global-scope definitions -----------------------------------------*/
QHsm * const the_hand = (QHsm *)&hand;       /* the opaque pointer */

void getState(QHsm * const me, uint8_t *color, uint16_t *blinkOn, uint16_t *blinkOff, uint8_t *vibro) {
    * color = ((Hand *)me)->fbColor;
    * blinkOn = ((Hand *)me)->fbBlinkOn;
    * blinkOff = ((Hand *)me)->fbBlinkOff;
    * vibro = ((Hand *)me)->fbVibro;
}

/*${SMs::Hand_ctor} ........................................................*/
void Hand_ctor(QHsm * const me) {
    Hand * hand = (Hand *)me;
    QHsm_ctor(&hand->super, Q_STATE_CAST(&Hand_initial));
    QMSM_INIT(me, (QEvt *)0);
    vibro(hand, 0);
    blinkStop(hand);
}
/*${SMs::Hand} .............................................................*/
/*${SMs::Hand::SM} .........................................................*/
static QState Hand_initial(Hand * const me, QEvt const * const e) {
    /* ${SMs::Hand::SM::initial} */
    (void)e; /* avoid compiler warning */
    me->Timer = 0;

    return Q_TRAN(&Hand_ready);
}
/*${SMs::Hand::SM::active} .................................................*/
static QState Hand_active(Hand * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${SMs::Hand::SM::active} */
        case Q_ENTRY_SIG: {
            if (DebugSM) {
                printf("Hand active;");
            }

            status_ = Q_HANDLED();
            break;
        }
        /* ${SMs::Hand::SM::active::TICK_SEC} */
        case TICK_SEC_SIG: {
            if (me->Timer > 0) {
                if (DebugSM) {
                    printf("%us", me->Timer-1);
                }
                me->Timer--;
            }
            /* ${SMs::Hand::SM::active::TICK_SEC::[me->Timer==1]} */
            if (me->Timer == 1) {
                me->Timer = 0;
                status_ = Q_TRAN(&Hand_ready);
            }
            /* ${SMs::Hand::SM::active::TICK_SEC::[else]} */
            else {
                status_ = Q_HANDLED();
            }
            break;
        }
        /* ${SMs::Hand::SM::active::TERMINATE} */
        case TERMINATE_SIG: {
            status_ = Q_TRAN(&Hand_final);
            break;
        }
        /* ${SMs::Hand::SM::active::CHARGE} */
        case CHARGE_SIG: {
            status_ = Q_TRAN(&Hand_charged);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${SMs::Hand::SM::active::charged} ........................................*/
static QState Hand_charged(Hand * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${SMs::Hand::SM::active::charged} */
        case Q_ENTRY_SIG: {
            if (DebugSM) {
                printf("charged;");
                printf("vibro 30;");
            }
            vibro(me, 30);
            me->Timer = 3 + 1;
            status_ = Q_HANDLED();
            break;
        }
        /* ${SMs::Hand::SM::active::charged::SONG} */
        case SONG_SIG: {
            status_ = Q_TRAN(&Hand_song);
            break;
        }
        /* ${SMs::Hand::SM::active::charged::THROW} */
        case THROW_SIG: {
            me->Color = WHITE;
            status_ = Q_TRAN(&Hand_throw);
            break;
        }
        /* ${SMs::Hand::SM::active::charged::PUNCH} */
        case PUNCH_SIG: {
            me->Color = RED;
            status_ = Q_TRAN(&Hand_cast_direct);
            break;
        }
        /* ${SMs::Hand::SM::active::charged::LIFT} */
        case LIFT_SIG: {
            me->Color = YELLOW;
            status_ = Q_TRAN(&Hand_cast_direct);
            break;
        }
        /* ${SMs::Hand::SM::active::charged::WARP} */
        case WARP_SIG: {
            me->Color = VIOLET;
            status_ = Q_TRAN(&Hand_cast_direct);
            break;
        }
        /* ${SMs::Hand::SM::active::charged::SINGULAR} */
        case SINGULAR_SIG: {
            status_ = Q_TRAN(&Hand_singularity);
            break;
        }
        /* ${SMs::Hand::SM::active::charged::BARRIER} */
        case BARRIER_SIG: {
            status_ = Q_TRAN(&Hand_barrier);
            break;
        }
        /* ${SMs::Hand::SM::active::charged::CLEANSE} */
        case CLEANSE_SIG: {
            me->Color = GREEN;
            status_ = Q_TRAN(&Hand_cleanse);
            break;
        }
        default: {
            status_ = Q_SUPER(&Hand_active);
            break;
        }
    }
    return status_;
}
/*${SMs::Hand::SM::active::song} ...........................................*/
static QState Hand_song(Hand * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${SMs::Hand::SM::active::song} */
        case Q_ENTRY_SIG: {
            if (DebugSM) {
                printf("song;");
                printf("vibro 100;");
                printf("blink_fast(ORANGE)");
            }
            vibro(me, 100);
            blinkFast(me, ORANGE);
            me->Timer = 5 + 1;
            //blink_fast(ORANGE);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Hand_active);
            break;
        }
    }
    return status_;
}
/*${SMs::Hand::SM::active::ready} ..........................................*/
static QState Hand_ready(Hand * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${SMs::Hand::SM::active::ready} */
        case Q_ENTRY_SIG: {
            if (DebugSM) {
                printf("hand ready;");
                printf("vibro(OFF);blink_stop();\n\r");
            }
            vibro(me, 0);
            blinkStop(me);
            //vibro(OFF);
            //blink_stop();
            me->Color = BLANK;
            status_ = Q_HANDLED();
            break;
        }
        /* ${SMs::Hand::SM::active::ready::CHARGE} */
        case CHARGE_SIG: {
            status_ = Q_TRAN(&Hand_charged);
            break;
        }
        default: {
            status_ = Q_SUPER(&Hand_active);
            break;
        }
    }
    return status_;
}
/*${SMs::Hand::SM::active::cast_direct} ....................................*/
static QState Hand_cast_direct(Hand * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${SMs::Hand::SM::active::cast_direct} */
        case Q_ENTRY_SIG: {
            if (DebugSM) {
                printf("cast_direct;");
                printf("vibro 60;");
            }
            vibro(me, 60);
            me->Timer = 3 + 1;
            status_ = Q_HANDLED();
            break;
        }
        /* ${SMs::Hand::SM::active::cast_direct::RELEASE} */
        case RELEASE_SIG: {
            status_ = Q_TRAN(&Hand_release);
            break;
        }
        /* ${SMs::Hand::SM::active::cast_direct::PWR_RELEASE} */
        case PWR_RELEASE_SIG: {
            status_ = Q_TRAN(&Hand_pwr_release);
            break;
        }
        default: {
            status_ = Q_SUPER(&Hand_active);
            break;
        }
    }
    return status_;
}
/*${SMs::Hand::SM::active::release} ........................................*/
static QState Hand_release(Hand * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${SMs::Hand::SM::active::release} */
        case Q_ENTRY_SIG: {
            if (DebugSM) {
                printf("released;");
                printf("vibro 100;");
                printf("blink_slow(%s);", ColorNames[me->Color].Name);
            }
            vibro(me, 100);
            blinkSlow(me, me->Color);
            me->Timer = 5 + 1;
            //blink_slow(me->Color);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Hand_active);
            break;
        }
    }
    return status_;
}
/*${SMs::Hand::SM::active::singularity} ....................................*/
static QState Hand_singularity(Hand * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${SMs::Hand::SM::active::singularity} */
        case Q_ENTRY_SIG: {
            if (DebugSM) {
                printf("singularity;");
                printf("vibro 100;");
                printf("blink_fast(WHITE)");
            }
            vibro(me, 100);
            blinkFast(me, WHITE);
            me->Timer = 5 + 1;
            //blink_fast(ORANGE);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Hand_active);
            break;
        }
    }
    return status_;
}
/*${SMs::Hand::SM::active::barrier} ........................................*/
static QState Hand_barrier(Hand * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${SMs::Hand::SM::active::barrier} */
        case Q_ENTRY_SIG: {
            if (DebugSM) {
                printf("barrier;");
                printf("vibro(100);");
                printf("blink_slow(GREEN)");
            }
            vibro(me, 100);
            blinkSlow(me, GREEN);
            me->Timer = 5 + 1;
            //blink_fast(ORANGE);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Hand_active);
            break;
        }
    }
    return status_;
}
/*${SMs::Hand::SM::active::pwr_release} ....................................*/
static QState Hand_pwr_release(Hand * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${SMs::Hand::SM::active::pwr_release} */
        case Q_ENTRY_SIG: {
            if (DebugSM) {
                printf("pwr_released;");
                printf("vibro 100;");
                printf("blink_fast(%s);", ColorNames[me->Color].Name);
            }
            vibro(me, 100);
            blinkFast(me, me->Color);
            me->Timer = 5 + 1;
            //blink_slow(me->Color);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Hand_active);
            break;
        }
    }
    return status_;
}
/*${SMs::Hand::SM::active::throw} ..........................................*/
static QState Hand_throw(Hand * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${SMs::Hand::SM::active::throw} */
        case Q_ENTRY_SIG: {
            if (DebugSM) {
                printf("throw;");
                printf("vibro(60);");
            }
            vibro(me, 60);
            me->Timer = 3 + 1;

            status_ = Q_HANDLED();
            break;
        }
        /* ${SMs::Hand::SM::active::throw::RELEASE} */
        case RELEASE_SIG: {
            status_ = Q_TRAN(&Hand_release);
            break;
        }
        default: {
            status_ = Q_SUPER(&Hand_active);
            break;
        }
    }
    return status_;
}
/*${SMs::Hand::SM::active::cleanse} ........................................*/
static QState Hand_cleanse(Hand * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${SMs::Hand::SM::active::cleanse} */
        case Q_ENTRY_SIG: {
            if (DebugSM) {
                printf("cleanse;");
                printf("vibro(60);");
            }
            vibro(me, 60);
            me->Timer = 3 + 1;

            status_ = Q_HANDLED();
            break;
        }
        /* ${SMs::Hand::SM::active::cleanse::PWR_RELEASE} */
        case PWR_RELEASE_SIG: {
            status_ = Q_TRAN(&Hand_pwr_release);
            break;
        }
        default: {
            status_ = Q_SUPER(&Hand_active);
            break;
        }
    }
    return status_;
}
/*${SMs::Hand::SM::final} ..................................................*/
static QState Hand_final(Hand * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${SMs::Hand::SM::final} */
        case Q_ENTRY_SIG: {
            printf("\nBye! Bye!\n");
            exit(0);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}


